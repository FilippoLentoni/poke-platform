"""Catalog of database tables and example queries for poke-platform."""

from __future__ import annotations

from dataclasses import dataclass
from typing import List


@dataclass(frozen=True)
class JoinKey:
    left: str
    right: str
    description: str


@dataclass(frozen=True)
class QueryInfo:
    name: str
    sql: str
    description: str
    join_keys: List[str]


TABLES = {
    "tracked_asset": {
        "description": "Asset tracking list with activation status and tags.",
        "columns": [
            "asset_id",
            "is_active",
            "added_reason",
            "added_ts",
            "tags",
        ],
    },
    "card_metadata": {
        "description": "Pokemon card metadata sourced from PTCG API.",
        "columns": [
            "asset_id",
            "ptcg_card_id",
            "name",
            "set_id",
            "set_name",
            "set_release_date",
            "number",
            "rarity",
            "artist",
            "images_json",
            "raw_json",
            "updated_ts",
        ],
    },
    "universe_run": {
        "description": "Audit log for universe updater runs.",
        "columns": [
            "run_id",
            "ts_started",
            "ts_finished",
            "note",
            "new_sets",
            "new_cards",
        ],
    },
    "tcgplayer_price_snapshot": {
        "description": "Daily price snapshots from TCGplayer per asset/variant.",
        "columns": [
            "snapshot_date",
            "snapshot_ts",
            "asset_id",
            "variant",
            "currency",
            "market",
            "low",
            "mid",
            "high",
            "direct_low",
            "url",
            "source_updated_at",
            "extra",
        ],
    },
    "cardmarket_price_snapshot": {
        "description": "Daily price snapshots from Cardmarket per asset/variant.",
        "columns": [
            "snapshot_date",
            "snapshot_ts",
            "asset_id",
            "variant",
            "currency",
            "avg1",
            "avg7",
            "avg30",
            "low_price",
            "trend_price",
            "url",
            "source_updated_at",
            "extra",
        ],
    },
    "trade_proposal": {
        "description": "Buy/sell proposals generated by strategies or API calls.",
        "columns": [
            "proposal_id",
            "proposal_date",
            "ts_created",
            "action",
            "asset_id",
            "qty",
            "target_price",
            "confidence",
            "rationale_json",
            "status",
            "decision",
            "decision_reason",
            "decided_ts",
        ],
    },
    "valuation_daily": {
        "description": "Daily valuation outputs from strategies.",
        "columns": [
            "val_date",
            "asset_id",
            "market_price",
            "smooth_price",
            "forecast_price",
            "gap",
            "gap_pct",
            "confidence",
            "rationale_json",
            "strategy_name",
            "strategy_version",
            "run_id",
            "ts_created",
        ],
    },
    "strategy_run": {
        "description": "Audit log for strategy runner executions.",
        "columns": [
            "run_id",
            "run_date",
            "ts_started",
            "strategy_name",
            "strategy_version",
            "inserted_proposals",
            "note",
        ],
    },
    "proposal_run_link": {
        "description": "Link table connecting proposals to a strategy run.",
        "columns": [
            "run_id",
            "proposal_id",
        ],
    },
    "portfolio_holding": {
        "description": "Current portfolio holdings and cost basis.",
        "columns": [
            "asset_id",
            "qty",
            "avg_cost",
            "updated_ts",
        ],
    },
}


JOIN_KEYS = [
    JoinKey(
        left="tracked_asset.asset_id",
        right="card_metadata.asset_id",
        description="Metadata for tracked assets.",
    ),
    JoinKey(
        left="card_metadata.asset_id",
        right="tcgplayer_price_snapshot.asset_id",
        description="Attach TCGplayer pricing to card metadata.",
    ),
    JoinKey(
        left="card_metadata.asset_id",
        right="cardmarket_price_snapshot.asset_id",
        description="Attach Cardmarket pricing to card metadata.",
    ),
    JoinKey(
        left="valuation_daily.asset_id",
        right="card_metadata.asset_id",
        description="Enrich valuations with card details.",
    ),
    JoinKey(
        left="trade_proposal.asset_id",
        right="card_metadata.asset_id",
        description="Enrich proposals with card details.",
    ),
    JoinKey(
        left="proposal_run_link.proposal_id",
        right="trade_proposal.proposal_id",
        description="Resolve proposals in a strategy run.",
    ),
    JoinKey(
        left="proposal_run_link.run_id",
        right="strategy_run.run_id",
        description="Tie proposals back to strategy runs.",
    ),
    JoinKey(
        left="valuation_daily.run_id",
        right="strategy_run.run_id",
        description="Tie valuations back to strategy runs.",
    ),
    JoinKey(
        left="portfolio_holding.asset_id",
        right="card_metadata.asset_id",
        description="Attach card metadata to holdings.",
    ),
]


QUERIES = [
    QueryInfo(
        name="active_tracked_assets",
        sql="SELECT COUNT(*) AS active_tracked FROM tracked_asset WHERE is_active=true;",
        description="Count active tracked assets.",
        join_keys=["tracked_asset.asset_id -> card_metadata.asset_id"],
    ),
    QueryInfo(
        name="card_metadata_count",
        sql="SELECT COUNT(*) AS card_metadata_count FROM card_metadata;",
        description="Total number of cards with metadata.",
        join_keys=["card_metadata.asset_id -> tracked_asset.asset_id"],
    ),
    QueryInfo(
        name="latest_metadata_update",
        sql="SELECT MAX(updated_ts) AS latest_updated_ts FROM card_metadata;",
        description="Most recent metadata update timestamp.",
        join_keys=[],
    ),
    QueryInfo(
        name="recent_cards",
        sql=(
            "SELECT asset_id, name, set_name, rarity, updated_ts "
            "FROM card_metadata ORDER BY updated_ts DESC LIMIT 50;"
        ),
        description="Sample of recently updated cards.",
        join_keys=["card_metadata.asset_id -> tracked_asset.asset_id"],
    ),
    QueryInfo(
        name="tcgplayer_latest_prices",
        sql=(
            "SELECT asset_id, variant, market, low, mid, high, snapshot_date "
            "FROM tcgplayer_price_snapshot "
            "ORDER BY snapshot_date DESC LIMIT 50;"
        ),
        description="Latest TCGplayer price snapshots.",
        join_keys=["tcgplayer_price_snapshot.asset_id -> card_metadata.asset_id"],
    ),
    QueryInfo(
        name="cardmarket_latest_prices",
        sql=(
            "SELECT asset_id, variant, avg1, avg7, avg30, trend_price, snapshot_date "
            "FROM cardmarket_price_snapshot "
            "ORDER BY snapshot_date DESC LIMIT 50;"
        ),
        description="Latest Cardmarket price snapshots.",
        join_keys=["cardmarket_price_snapshot.asset_id -> card_metadata.asset_id"],
    ),
    QueryInfo(
        name="latest_valuations_with_metadata",
        sql=(
            "WITH latest AS (SELECT MAX(val_date) AS val_date FROM valuation_daily) "
            "SELECT vd.val_date, vd.asset_id, vd.market_price, vd.forecast_price, vd.gap_pct, "
            "vd.confidence, cm.name, cm.set_name, cm.rarity "
            "FROM valuation_daily vd "
            "JOIN latest l ON vd.val_date = l.val_date "
            "LEFT JOIN card_metadata cm ON cm.asset_id = vd.asset_id "
            "ORDER BY vd.gap_pct DESC LIMIT 50;"
        ),
        description="Latest valuation outputs enriched with metadata.",
        join_keys=["valuation_daily.asset_id -> card_metadata.asset_id"],
    ),
    QueryInfo(
        name="proposals_today",
        sql=(
            "SELECT proposal_id, proposal_date, ts_created, action, asset_id, qty, target_price, "
            "confidence, status FROM trade_proposal WHERE proposal_date = CURRENT_DATE "
            "ORDER BY ts_created DESC;"
        ),
        description="Today's trade proposals.",
        join_keys=["trade_proposal.asset_id -> card_metadata.asset_id"],
    ),
    QueryInfo(
        name="proposal_run_summary",
        sql=(
            "SELECT sr.run_id, sr.run_date, sr.strategy_name, sr.strategy_version, "
            "tp.proposal_id, tp.asset_id, tp.action, tp.target_price "
            "FROM proposal_run_link prl "
            "JOIN strategy_run sr ON sr.run_id = prl.run_id "
            "JOIN trade_proposal tp ON tp.proposal_id = prl.proposal_id "
            "ORDER BY sr.run_date DESC, tp.ts_created DESC LIMIT 100;"
        ),
        description="Tie proposals back to strategy runs.",
        join_keys=[
            "proposal_run_link.run_id -> strategy_run.run_id",
            "proposal_run_link.proposal_id -> trade_proposal.proposal_id",
        ],
    ),
    QueryInfo(
        name="portfolio_with_metadata",
        sql=(
            "SELECT ph.asset_id, ph.qty, ph.avg_cost, cm.name, cm.set_name, cm.rarity "
            "FROM portfolio_holding ph "
            "LEFT JOIN card_metadata cm ON cm.asset_id = ph.asset_id "
            "ORDER BY ph.updated_ts DESC;"
        ),
        description="Portfolio holdings enriched with card details.",
        join_keys=["portfolio_holding.asset_id -> card_metadata.asset_id"],
    ),
    QueryInfo(
        name="universe_run_history",
        sql=(
            "SELECT run_id, ts_started, ts_finished, new_sets, new_cards, note "
            "FROM universe_run ORDER BY ts_started DESC LIMIT 50;"
        ),
        description="Universe updater run history.",
        join_keys=[],
    ),
]


def example_usage() -> None:
    """Example of wiring to read_sql from scripts.db_notebook_helpers."""
    # from scripts.db_notebook_helpers import read_sql
    # from notebooks.db_explore import REGION, SECRET_ARN
    # df = read_sql(QUERIES[0].sql, region=REGION, secret_arn=SECRET_ARN)
    # print(df.head())
    raise SystemExit("Import this module and use QUERIES with read_sql().")
